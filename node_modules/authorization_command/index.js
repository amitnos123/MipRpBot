module.exports = class authorization_command {
  
	constructor(dataDir, dataFileName, settingsDir, settingsFileName) {
        if(dataDir === '') {
        throw new Error('authorization_command didn\'t get data directory path');
        }
            this.dataDir = dataDir;
        if(dataFileName === '' || dataFileName === undefined) {
            this.dataFileName = 'AUTHORIZATION';
        } else {
            this.dataFileName = dataFileName;
        }

        if(settingsDir === '' || settingsDir === undefined) {
            this.settingsDir = dataDir;
        } else {
            this.settingsDir = settingsDir;
        }

        if(settingsFileName === '' || settingsFileName === undefined) {
            this.settingsFileName = 'AUTHORIZE_ROLE';
        } else {
            this.settingsFileName = settingsFileName;
        }

        this.authArr = load_auth_data(this.dataDir, this.dataFileName);
        this.authSettingsArr = load_auth_settings(this.settingsDir, this.settingsFileName);
	}
  
	auth_dm_command(member, id) {
        if(id === undefined) throw new Error('auth_dm_command didn\'t get a id');
        console.log('auth_dm_command');
    }

    auth_text_command(member, id) {
        if(id === undefined) throw new Error('auth_text_command didn\'t get a id');
        const constants = require('consts');
        if(this.authArr[id].type === constants.AUTHORIZATION_ROLE) { //If the command with auth by the member role
            return auth_text_command_by_role(member, this.authArr[id]);
        } else if(this.authArr[id].type === constants.AUTHORIZATION_SETTINGS) {//If the command with auth by the member settings
            return auth_text_command_by_settings(member, this.authArr[id], this.authSettingsArr);
        }
        return true;
    }
};

function load_auth_data(dataDir, dataFileName) {
    const filePath = dataDir + '\\'+ dataFileName;

    delete require.cache[require.resolve(filePath)]; //delete cache
    return require(filePath);
}

function load_auth_settings(settingsDir, settingsFileName) {
    const filePath = settingsDir + '\\'+ settingsFileName;

    delete require.cache[require.resolve(filePath)]; //delete cache
    return require(filePath);
}

/// PARAM
//member - The guild member which want to use the command
//authData - Authorization data on a spesific command
/// Description - Return true or false for, if the member may use the command based on the member roles in the guild
function auth_text_command_by_role(member, authData) {
    //filter that will only take roles which the member have and the role exist in authData
    const filteredRoles = member.roles.filter(function(role){return authData.roles.includes(role.name);});
    if(filteredRoles.size > 0) { return true; } //If better then 0, the member have the role to use the command
    else {return false;} //The member doeesn't have the auth to use the command
}

/// PARAM
//member - The guild member which want to use the command
//authData - Authorization data on a spesific command
//authSettings - Authorization settings. The bot roles group
/// Description - Return true or false for, if the member may use the command based on the member roles\settings in the bot. Root able to do all
function auth_text_command_by_settings(member, authData, authSettings) {
    const constants = require('consts');

    if(authSettings[constants.AUTHORIZATION_SETTINGS_ROOT].includes(member.user.username)) { //If member is root, then let the user use the command without checking
        return true;
    }

    //foreach settings the commands has:    
    //For given setting for the command, will check, if member has it. If found, return true, else continue search until the end
    let memberAllowed = false;
    authData.settings.forEach(function(setting){
        if(authSettings[setting].includes(member.user.username)) {
            memberAllowed = true; //If it's find that the member belong to one of the settings which are allowed to use the command, will turn to true
        }
    });

    return memberAllowed;
}