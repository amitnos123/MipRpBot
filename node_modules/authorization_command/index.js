const log_writer = require('log_writer');
const constants = require('consts');
const lw = new log_writer(constants.LOG_DIRECTORY_PATH);

module.exports = class authorization_command {
    
    /**
     * Constructor authorization_command object
     * @constructor
     * @param {string} dataDir - The path to the directory which the data on authorization for the commands.
     * @param {string} dataFileName - The name of the file which hold the data on authorization for the command. Default value is 'AUTHORIZATION.json'
     * @param {string} settingsDir - The path to the directory which the data on authorize setting. Default value is the value of settingsDir
     * @param {string} settingsFileName - The name of the file which hold the data on authorize setting. Default value is 'AUTHORIZE_ROLE.json'
     */
    constructor(dataDir, dataFileName, settingsDir, settingsFileName) {
        if (dataDir === '' || dataDir === undefined) {
            const errorMessage = 'authorization_command didn\'t get data directory path';
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        this.dataDir = dataDir;
        if (dataFileName === '' || dataFileName === undefined) {
            this.dataFileName = 'AUTHORIZATION.json';
        } else {
            this.dataFileName = dataFileName;
        }

        if (settingsDir === '' || settingsDir === undefined) {
            this.settingsDir = dataDir;
        } else {
            this.settingsDir = settingsDir;
        }

        if (settingsFileName === '' || settingsFileName === undefined) {
            this.settingsFileName = 'AUTHORIZE_ROLE.json';
        } else {
            this.settingsFileName = settingsFileName;
        }

        this.authDataArr = load_auth_data(this.dataDir, this.dataFileName);
        this.authSettingsArr = load_auth_settings(this.settingsDir, this.settingsFileName);
    }
    
    /**
     * Return true or false for, if the member is allowed to use the command. Used for commands which are called through DM
     * @param {GuildMember} member - The guild member which want to use the command
     * @param {string} id - id of the command
     * @returns {boolean} - Is the member is allowed to use the command
     */
    auth_dm_command(member, id) {
        if (member === undefined){
            const errorMessage = 'auth_dm_command didn\'t get a member';
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        if (id === undefined){ 
            const errorMessage = 'auth_dm_command didn\'t get a id';
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        console.log('auth_dm_command');
    }
    
    /**
     * Return true or false for, if the member is allowed to use the command. Used for commands which are called through the server
     * @param {GuildMember} member - The guild member which want to use the command
     * @param {string} id - id of the command
     * @returns {boolean} - Is the member is allowed to use the command
     */
    auth_text_command(member, id) {
        if (member === undefined) {
            const errorMessage = 'auth_text_command didn\'t get a member';
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        if (id === undefined ){
            const errorMessage = 'auth_text_command didn\'t get a id';
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }

        lw.logMessage('debug', `User ${member.user.username} requested to use command with id=${id}`);

        if (this.authDataArr[id].type === constants.AUTHORIZATION_ROLE) { //If the command with auth by the member role
            return auth_text_command_by_role(member, this.authDataArr[id]);
        } else if (this.authDataArr[id].type === constants.AUTHORIZATION_SETTINGS) {//If the command with auth by the member settings
            return auth_text_command_by_settings(member, this.authDataArr[id], this.authSettingsArr);
        }
        return true;
    }
    
    /**
     * Create a command authorization
     * @param {string} id - Id of the command
     * @param {string} type - The type of the authorization. For examples: 'role' 'settings'
     * @param {Array} authGroup - The group which is authorize to use the command. For example, if type is 'role', then the array will hold all the roles which are allowed to use the command
     * @returns {void}
     */
    auth_create_command(id, authType, authGroup) {
        const constants = require('consts');

        if(this.authDataArr[id] !== undefined) {
            const errorMessage = `authorization for the id='${id}' already exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }

        this.authDataArr[id] = {type: authType};

        switch(authType) {
            case constants.AUTHORIZATION_TYPE_ROLE:
                this.authDataArr[id].roles = authGroup;
                break;
            case constants.AUTHORIZATION_TYPE_SETTINGS:
                this.authDataArr[id].settings = authGroup;
                break;
            default:
                return;
                // break;
        }

        write_auth_data(this.dataDir, this.dataFileName, this.authDataArr);
    }
    
    /**
     * Update a command authorization
     * @param {string} id - Id of the command
     * @param {string} type - The type of the authorization. For examples: 'role' 'settings'
     * @param {Array} authGroup - The group which is authorize to use the command. For example, if type is 'role', then the array will hold all the roles which are allowed to use the command
     * @returns {void}
     */
    auth_update_command(id, authType, authGroup) {
        const constants = require('consts');

        if(this.authDataArr[id] === undefined) {
            const errorMessage = `authorization for the id='${id}' doesn't exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }

        if(authType !== undefined && authType !== null) {
            this.authDataArr[id].type = authType;
        }
        

        switch(this.authDataArr[id].type) { // this.authDataArr[id].type is already updated with the new one
            case constants.AUTHORIZATION_TYPE_ROLE:
                this.authDataArr[id].roles = authGroup;
                break;
            case constants.AUTHORIZATION_TYPE_SETTINGS:
                this.authDataArr[id].settings = authGroup;
                break;
            default:
                console.log('fall');
                return;
                // break;
        }

        write_auth_data(this.dataDir, this.dataFileName, this.authDataArr);
    }
    
    /**
     * Remove the command from authorization
     * @param {string} id - Id of the command
     * @returns {void}
     */
    auth_remove_command(id) {
        if(this.authDataArr[id] === undefined) {
            const errorMessage = `authorization for the id='${id}' doesn't exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        
        delete this.authDataArr[id];

        write_auth_data(this.dataDir, this.dataFileName, this.authDataArr);
    }
    
    /**
     * Create a new authorize setting
     * @param {string} setting - The name of the new setting
     * @returns {void}
     */
    auth_create_setting_command(setting) { // need to test
        if(this.authSettingsArr[setting] !== undefined) {
            const errorMessage = `authorization setting id='${id}' already exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }

        this.authSettingsArr[setting] = [];

        write_auth_settings(this.settingsDir, this.settingsFileName, this.authSettingsArr);
    }
    
    /**
     * Remove authorize setting
     * @param {string} setting - The name of the setting which will be removed
     * @returns {void}
     */
    auth_remove_setting_command(setting) { // need to test
        if(this.authSettingsArr[setting] === undefined) {
            const errorMessage = `authorization setting '${setting}' doesn't exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        
        delete this.authSettingsArr[setting];

        write_auth_settings(this.settingsDir, this.settingsFileName, this.authSettingsArr);
    }
    
    /**
     * Adding user to authorize setting
     * @param {string} setting - The name of the setting which will be removed
     * @param {GuildMember\array(GuildMember)} memberArr - Member\s which will be added to the authorize setting
     * @returns {void}
     */
    auth_add_user_to_settings_command(setting, memberArr) { // need to test
        if(this.authSettingsArr[setting] === undefined) {
            const errorMessage = `authorization setting '${setting}' doesn't exist`;
            lw.logMessage('error', errorMessage);
            throw new Error(errorMessage);
        }
        
        if(Array.isArray(memberArr)) { // memberArr is array(GuildMember)
            memberArr.forEach(function(member){
                this.authSettingsArr[setting].push(member.user.username);
            });
        } else { // memberArr is GuildMember
            this.authSettingsArr[setting].push(memberArr.user.username);
        }

        write_auth_settings(this.settingsDir, this.settingsFileName, this.authSettingsArr);
    }
};

/**
 * Return the authorization data from the file, without using the cache, from the given directory and file name
 * @param {string} dataDir - The directory where the file is
 * @param {string} dataFileName - The name of the file which hold the data for the settings of the auth
 * @returns {object} - The authorization data from the file
 */
function load_auth_data(dataDir, dataFileName) {
    const filePath = dataDir + '\\' + dataFileName;
    delete require.cache[require.resolve(filePath)]; //delete cache

    return (require(filePath));
}

/**
 * Return the auth settings data from the file, without using the cache, from the given directory and file name
 * @param {string} settingsDir - The directory where the file is
 * @param {string} settingsFileName - The name of the file which hold the data for the settings of the auth
 * @returns {object} - The authorization settings from the file
 */
function load_auth_settings(settingsDir, settingsFileName) {
    const filePath = settingsDir + '\\' + settingsFileName;

    delete require.cache[require.resolve(filePath)]; //delete cache
    return require(filePath);
}

/**
 * Return true or false for, if the member is allowed to use the command based on the member roles in the guild
 * @param {GuildMember} member - The guild member which want to use the command
 * @param {Object} authData - Authorization data on a spesific command
 * @returns {boolean} - Is the member is allowed to use the command
 */
function auth_text_command_by_role(member, authData) {
    //filter that will only take roles which the member have and the role exist in authData
    const filteredRoles = member.roles.filter(function (role) { return authData.roles.includes(role.name); });
    if (filteredRoles.size > 0) { 
        //If better then 0, the member have the role to use the command
        lw.logMessage('debug', `User ${member.user.username} has roles which are authorize to use the command ${filteredRoles}`);
        return true;
     } 
    else { 
        //The member doeesn't have the auth to use the command
        lw.logMessage('debug', `User ${member.user.username} doesn't has a role which is authorize to use the command`);
        return false;
     } 
}

/**
 * Return true or false for, if the member is allowed to use the command based on the member roles\settings in the bot. Root able to do all
 * @param {GuildMember} member - The guild member which want to use the command
 * @param {Object} authData - Authorization data on a spesific command
 * @param {Array} authSettings - Authorization settings. The bot roles group
 * @returns {boolean} - Is the member is allowed to use the command
 */
function auth_text_command_by_settings(member, authData, authSettings) {
    const constants = require('consts');

    //If member is root, then let the user use the command without checking
    if (authSettings[constants.AUTHORIZATION_SETTINGS_ROOT].includes(member.user.username)) {
        lw.logMessage('debug', `User ${member.user.username} was authorize because user is root`);
        return true;
    }

    //foreach settings the commands has:    
    //For given setting for the command, will check, if member has it. If found, return true, else continue search until the end
    let memberAllowed = false;
    authData.settings.forEach(function (setting) {
        if (authSettings[setting].includes(member.user.username)) {
            lw.logMessage('debug', `User ${member.user.username} was authorize because user is ${setting}`);
            memberAllowed = true; //If it's find that the member belong to one of the settings which are allowed to use the command, will turn to true
        }
    });

    if(!memberAllowed) {lw.logMessage('debug', `User ${member.user.username} wasn't authorize`);}

    return memberAllowed;
}

/**
  * Write to the authorization data file the authSettings. Update the file
 * @param {string} dataDir - The path to the directory which the data on authorization for the commands.
 * @param {string} dataFileName - The name of the file which hold the data on authorization for the command. Default value is 'AUTHORIZATION'
 * @param {JSON} authData - Authorization data which will be written
 * @returns {void}
 */
function write_auth_data(dataDir, dataFileName, authData) {
    const fs = require('fs');
       
    const filePath = dataDir + '\\' + dataFileName;

    fs.writeFile(filePath, JSON.stringify(authData), function(err) {
        if (err) {
            lw.logMessage('error', err);
            throw err;
        }
        lw.logMessage('debugs', `Authorization data was updated to ${JSON.stringify(authData)}`);
    });
}

/**
 * Write to the authorization settings file the authSettings. Update the file
 * @param {string} settingsDir - The path to the directory which the data on authorize setting. Default value is the value of settingsDir
 * @param {string} settingsFileName - The name of the file which hold the data on authorize setting. Default value is 'AUTHORIZE_ROLE'
 * @param {JSON} authSettings - Authorization settings which will be written
 * @returns {void}
 */
function write_auth_settings(settingsDir, settingsFileName, authSettings) {
    const fs = require('fs');
       
    const filePath = settingsDir + '\\' + settingsFileName;

    fs.writeFile(filePath, JSON.stringify(authSettings), function(err) {
        if (err) {
            lw.logMessage('error', err);
            throw err;
        }
        lw.logMessage('debugs', `Authorization settings was updated to ${JSON.stringify(authSettings)}`);
    });
}
     